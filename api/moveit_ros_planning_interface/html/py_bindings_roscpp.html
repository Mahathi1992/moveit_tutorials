<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<title>planning_interface: Creating Python bindings for C++ classes</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="jquery.js"></script>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Creating Python bindings for C++ classes </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section user"><dt>Problem</dt><dd>When creating Python bindings of C++ classes it may be necessary to have roscpp initialized (ros::init() called) when the instance of a particular C++ class is created. </dd></dl>
<dl class="section user"><dt>Example</dt><dd>For example, say we need python bindings for class Foo; A common approach to define functionality specific for the wrappers is to define: <div class="fragment"><div class="line"><span class="keyword">class </span>FooWrapper : <span class="keyword">public</span> Foo</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">...</div>
<div class="line">};</div>
</div><!-- fragment --> This allows defining additional functions in FooWrapper that are more amenable to the construction of Python bindings. Say that FooWrapper is now constructed because a Python programmer created the instance of the wrapped object. At that point, if Foo needs ros::init() to have been called, there is an error, because even if rospy is initialized, roscpp is not. </dd></dl>
<dl class="section user"><dt>Solutions</dt><dd>We can update class FooWrapper using the moveit_py_bindings_tools::ROScppInitializer class like so: <div class="fragment"><div class="line"><span class="keyword">class </span>FooWrapper : <span class="keyword">protected</span> ROScppInitializer</div>
<div class="line">                   <span class="keyword">public</span> Foo</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">FooWrapper(...) : ROScppInitializer(),</div>
<div class="line">                  Foo(...)</div>
<div class="line">{ }</div>
<div class="line">...</div>
<div class="line">};</div>
</div><!-- fragment --> This way it is ensured that the constructor of ROScppInitialier is called right before the instance of Foo is constructed (in the process of constructing FooWrapper). The advantage of this solution is that the Python programmer could not care less what roscpp is doing. Things will "just work". The downside of this solution is that if any command line arguments have been passed to the Python program, they are not forwarded to roscpp. But to forward these parameters an explicit function call needs to be made. For that we provide a function call </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->

<br clear="all" />
<hr size="1"><div style="align: right;">
<a href="http://wiki.ros.org/planning_interface">planning_interface</a><br />
Author(s): Ioan Sucan <isucan@google.com></br />
<small>autogenerated on Tue Oct 19 2021 16:48:03</small>
</div>
</body>
</html>
